werker-output bestaat altijd uit headers en evt. body
bij CGI: headers en body komen uit socket
bij bestand: headers komen uit stringstream, body uit bestand
bij ingebouwd: headers en body komen uit stringstream

dus: bij werker uitlezen
CGI: lees CGI
Resource (bestand/ingebouwd): eerst stringstream, dan bestand

headers worden:
bij CGI door het script geproduceerd, evt. aangevuld (bijv. zonder lengtespecificatie)
bij bestand door de server geproduceerd (bestandsextensie, omvangmeting, ...)
bij ingebouwd door de server geproduceerd (ligt vast)

lezen:
als er nog iets in de client stringstream zit: lees dat eerst uit
status:
	als de client stringstream niet leeg is: pending
	anders wait()

implementeer timeout voor CGI (x aantal seconden na laatste successvolle read); als timeout plaatsvindt tijdens headers: stuur timeout-response, anders foutinjectie
> als het CGI-proces afloopt voor de server alle data gelezen heeft, gaat alle achtergebleven data verloren
> dus wait() is niet per se de indicatie voor EOF
> read() = 0 ook niet, want het kan ook zijn dat er halverwege CGI even geen data beschikbaar is, maar dat die later nog wel komt
A het best zou zijn om ook de CGI-socket te pollen, bij hoge voorkeur op een andere poller dan die waar ook de client-sockets in zitten
B alternatief zonder poll kan zijn dat CGI::wait pas waitpid() doet als de laatste CGI::read() 0 teruggaf; deze waarde moet dan gecached worden <= is lelijk en stom en hacky, maar werkt waarschijnlijk gewoon
> optie B biedt daarentegen wel de mogelijkheid de timeout in CGI::wait() te integreren

post request veroorzaakt oneindige lus -> Worker::wait() controleert of gekoppeld bestand aan EOF zit, voor infile is dat nooit -> dit moet helemaal anders -_-

hoe moet foutinjectie werken? (dat is dus niet hetzelfde als een foutrespons: dit gaat om de situatie dat nadat de response line al verzonden is een fout optreedt)

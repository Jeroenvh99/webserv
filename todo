werker-output bestaat altijd uit headers en evt. body
bij CGI: headers en body komen uit socket
bij bestand: headers komen uit stringstream, body uit bestand
bij ingebouwd: headers en body komen uit stringstream

dus: bij werker uitlezen
CGI: lees CGI
Resource (bestand/ingebouwd): eerst stringstream, dan bestand

headers worden:
bij CGI door het script geproduceerd, evt. aangevuld (bijv. zonder lengtespecificatie)
bij bestand door de server geproduceerd (bestandsextensie, omvangmeting, ...)
bij ingebouwd door de server geproduceerd (ligt vast)

lezen:
als er nog iets in de client stringstream zit: lees dat eerst uit
status:
	als de client stringstream niet leeg is: pending
	anders wait()

post request veroorzaakt oneindige lus -> Worker::wait() controleert of gekoppeld bestand aan EOF zit, voor infile is dat nooit -> dit moet helemaal anders -_-

hoe moet foutinjectie werken? (dat is dus niet hetzelfde als een foutrespons: dit gaat om de situatie dat nadat de response line al verzonden is een fout optreedt) <== gewoon de verbinding yeeten

segfault in Server::_to_graveyard